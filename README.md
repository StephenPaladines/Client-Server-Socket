# Client-Server-Socket

Report
Architecture
	This project requires the student to create a quiz application that will interact with a user by grabbing some input. This input translates to an answer, question, or server response based on the character inserted. Given the need for a persistent source of data that will hold a user’s input, in this case being a question, a cloud database server was implemented. This database server is provided free for CISE students and can be accessed from within the storm and thunder servers. With this db, it is easy to insert, delete, and retrieve data that will continue to exist despite the server or client closing/shutting down. As for the means of communication, the client will interact with the server and vice versa using sockets. When the user passes a host and a port, both server and client will know where to meet and pass information accordingly.
Protocol:
	The client and server for this project used the TCP/IP protocol for communication. The reason this protocol is used is because of the need to have a consistent connection between server and client regardless of the state of the two. What this means is that we want a constant connection with the server even if the client closes. In the long run, this provides several benefits such as less OS overhead since our connection is already allocated, less congestion on the network, and consistent connections between server and clients.
Function & Variables:
	The entire project consists of several sub-components that allow for the client answer to function properly. To start off with, a socket object on the server side must be created to interact with the client, ‘socket.socket(.., ...)’. Initializing the ‘socket_stream’ as one of the parameters tells the client that a TCP connection will be used as the transportation layer. Once the object is created, it will be used to bind the host and port passed from the user to the client. The client will of course connect to the server with the respective host and port are passed.
	After creating the socket, a connection to the database will be created in order to insert the client side data ‘mysql.connector.connect(…..)’. With the correct parameters the database object connects to the server and will now allow information to be collected. The final section in the server side is the corresponding functionalities for each character option in the assignment. 
	To access each character, two ‘while loops’ are used to consistently receive input from the client. The first while loop allows for the server to connect to a new client and immediately receive input. This first while loop also helps new clients rejoin the server when a previous client crashed or disconnected. The second while loop is responsible for input sent from the client. If the client sends an input that is not associated to a command, then they’ll be prompted with the same ‘> ‘used for sending data until a valid argument is passed. Most functions inside the server repeat in structure and functionality. Before a command is executed, the server checks whether the command is valid or not using a ‘try except’ to prevent any potential runtime errors. If the try catch is successful, if the commands requires access to the server, a SQL query is sent with the respective function:insert, delete, or print
	On the client side, much of the same overhead is expected except the database connection since that function will be handled by server. Inside the client is one ‘while loop’ that will listen for user inputs and respond to each input, accordingly, ignoring invalid arguments in the process as well. The client side was the simplest application from the two since the main objective of the client is to take user input and send it directly to the server without worrying about what’s happening in the background. Inside each command was a function called ‘raw_input()’ which collected the input from the user and would pass the value to the ‘sendall()’ function. Send all would send the entire buffer directly to the server. Once the server is done, the client will expect a respond that will either be success or failure depending on data.
Error Handling:
	The most common use of error handling was dealing with characters that did not correspond to the functionalities mentioned in the scope. For example, if the user passes in the character, ‘j’, the client will respond with an invalid argument message followed by the opportunity to continue sending commands. Another important way error handling was implemented was checking when command line arguments were passed for certain functions. For example, the command, d, corresponds to the deleting function in our database. In order to delete a row from the database, a user must pass a value for which the query can be performed on; allows the question number to be related back to the question in the server. This error handling was done by checking the input size.
	The last common error prevention used in the project was using ‘try except’ for when the user attempted to manipulate the data. If an invalid argument was sent when attempting to perform a SQL command, the try would automatically go to the except portion of the function and catch the issue directly.
